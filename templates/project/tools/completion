#!/bin/sh
# Output shell completion scripts (bash, zsh)
set -eu

_this="$0"; _dir=${_this%/*}; _root=${_dir%/tools}
. "$_root/lib/common.sh"; . "$_root/lib/log.sh"; . "$_root/lib/args.sh"; . "$_root/lib/config.sh"

usage() {
  cat <<'__COMP_HELP__'
Usage: ${TOOLBOX_NAME} completion [bash|zsh]

Print a completion script for the given shell to stdout.
__COMP_HELP__
}

shell=${1:-}
case "$shell" in
  -h|--help|"") usage; [ -n "$shell" ] && exit 0 || exit 2 ;;
  bash)
    _prog="$TOOLBOX_NAME"
    cat <<'EOS' | sed "s/__PROG__/${_prog}/g"
_toolbox__collect_path() {
  local -n words=$1
  local upto=$2
  local path=()
  local i=1
  while (( i < upto )); do
    local token="${words[i]}"
    if [[ "$token" == "--" ]]; then
      break
    fi
    if [[ "$token" == -* ]]; then
      break
    fi
    path+=("$token")
    ((i++))
  done
  printf '%s\n' "${path[@]}"
}

_toolbox__meta_options() {
  local prog=$1; shift
  local opts=""
  local meta
  meta=$("$prog" __command_meta "$@" 2>/dev/null)
  local kind flags value desc
  while IFS='|' read -r kind flags value desc; do
    if [[ "$kind" == option ]]; then
      IFS=',' read -ra flag_list <<< "$flags"
      for flag in "${flag_list[@]}"; do
        opts="$opts $flag"
      done
    fi
  done <<< "$meta"
  printf '%s' "$opts"
}

_toolbox_complete() {
  local cur prev prog
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  prog=${COMP_WORDS[0]}

  if [[ "$prev" == "--config" ]]; then
    compopt -o filenames 2>/dev/null
    return 0
  fi

  local path=()
  while IFS= read -r token; do
    [ -n "$token" ] || continue
    path+=("$token")
  done < <(_toolbox__collect_path COMP_WORDS $COMP_CWORD)

  if (( ${#path[@]} == 0 )); then
    local cmds opts
    cmds=$("$prog" __commands 2>/dev/null)
    opts='-h --help -V --version --no-color --log-level --config help'
    COMPREPLY=( $(compgen -W "$cmds $opts" -- "$cur") )
    return 0
  fi

  if [[ "${path[0]}" == "help" ]]; then
    local cmds
    cmds=$("$prog" __commands 2>/dev/null)
    COMPREPLY=( $(compgen -W "$cmds" -- "$cur") )
    return 0
  fi

  local subs
  subs=$("$prog" __commands "${path[@]}" 2>/dev/null)
  if [[ -n "$subs" && "$cur" != -* ]]; then
    COMPREPLY=( $(compgen -W "$subs" -- "$cur") )
    return 0
  fi

  local opt_words
  opt_words=$(_toolbox__meta_options "$prog" "${path[@]}" 2>/dev/null)
  if [[ -n "$opt_words" ]]; then
    COMPREPLY=( $(compgen -W "$opt_words" -- "$cur") )
    return 0
  fi

  compopt -o filenames 2>/dev/null
}
complete -F _toolbox_complete __PROG__
EOS
    ;;
  zsh)
    _prog="$TOOLBOX_NAME"
    cat <<'EOS' | sed "s/__PROG__/${_prog}/g"
#compdef __PROG__
_toolbox__commands() {
  __PROG__ __commands "$@" 2>/dev/null
}

_toolbox__options() {
  __PROG__ __command_meta "$@" 2>/dev/null | awk -F'|' '$1=="option" { split($2, a, ","); for (i in a) print a[i]; }'
}

_toolbox_complete() {
  local state context path
  typeset -a path
  local words=(${=words})

  local i=2
  while (( i < CURRENT )); do
    local token=${words[i]}
    if [[ $token == -- ]]; then
      break
    fi
    if [[ $token == -* ]]; then
      break
    fi
    path+=$token
    ((i++))
  done

  if (( ${#path} == 0 )); then
    local -a cmds
    cmds=($(_toolbox__commands))
    _describe 'command' cmds
    _arguments '-h[help]' '--help[help]' '--no-color[disable color]' '--log-level[set log level]' '--config[config file]:file:_files' '-V[version]' '1: :->cmd'
    return
  fi

  if [[ ${path[1]} == help ]]; then
    local -a cmds
    cmds=($(_toolbox__commands))
    _describe 'command' cmds
    return
  fi

  local -a subs
  subs=($(_toolbox__commands ${path[@]}))
  if (( ${#subs} > 0 )) && [[ ${words[CURRENT]} != -* ]]; then
    _describe 'subcommand' subs
    return
  fi

  local -a opts
  opts=($(_toolbox__options ${path[@]}))
  if (( ${#opts} > 0 )); then
    _describe 'option' opts
    return
  fi

  _files
}
compdef _toolbox_complete __PROG__
EOS
    ;;
  *) err "unknown shell: %s" "$shell"; exit 2 ;;
esac
