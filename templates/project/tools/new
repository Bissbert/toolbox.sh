#!/bin/sh
# Scaffold a new subcommand (leaf or group)
set -eu

_this="$0"
case "$_this" in
  /*) : ;;
  *) _this=$(command -v -- "$_this" 2>/dev/null || printf %s "$_this")
     case "$_this" in
       /*) : ;;
       */*) _this=$(CDPATH= cd -- "${_this%/*}" && pwd -P)/${_this##*/} ;;
       *) _this=$(CDPATH= cd -- . && pwd -P)/$_this ;;
     esac ;;
esac
_dir=${_this%/*}
_root=${_dir%/tools}
. "$_root/lib/common.sh"; . "$_root/lib/log.sh"; . "$_root/lib/args.sh"; . "$_root/lib/config.sh"

usage() {
  cat <<'__NEW_HELP__'
Usage: ${TOOLBOX_NAME} new [--group] <command> [subcommand ...]

Scaffold a new command under tools/. Use --group to create a command group
(__main) that only exposes subcommands.

Examples:
  ${TOOLBOX_NAME} new hello
  ${TOOLBOX_NAME} new admin users list
  ${TOOLBOX_NAME} new --group admin
__NEW_HELP__
}

GROUP=0

while [ "$#" -gt 0 ]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    --group) GROUP=1; shift ;;
    --) shift; break ;;
    -*) err "unknown option: %s" "$1"; usage >&2; exit 2 ;;
    *) break ;;
  esac
done

[ "$#" -gt 0 ] || { usage >&2; exit 2; }

segments=""
append_segment() {
  if [ -z "$segments" ]; then
    segments=$1
  else
    segments="$segments $1"
  fi
}

split_token() {
  token=$1
  case $token in
    */*)
      first=${token%%/*}
      rest=${token#*/}
      append_segment "$first"
      [ -n "$rest" ] && split_token "$rest"
      ;;
    *)
      append_segment "$token"
      ;;
  esac
}

for arg in "$@"; do
  split_token "$arg"
done

[ -n "$segments" ] || { err "no command segments provided"; exit 2; }

cmd_name=$segments
usage_path=$cmd_name

# Convert segments into positional parameters for iteration
set -- $segments
count=$#
[ "$count" -gt 0 ] || { err "invalid command path"; exit 2; }

if [ "$GROUP" -eq 1 ]; then
  target_dir="$TOOLS_DIR"
  for seg do
    target_dir="$target_dir/$seg"
  done
  target="$target_dir/__main"
  mkdir -p "$target_dir"
  template="$TEMPLATE_DIR/command/group"
else
  target_dir="$TOOLS_DIR"
  while [ "$#" -gt 1 ]; do
    target_dir="$target_dir/$1"
    shift
  done
  last_segment=$1
  mkdir -p "$target_dir"
  target="$target_dir/$last_segment"
  template="$TEMPLATE_DIR/command/leaf"
fi

[ -f "$template" ] || { err "template not found: %s" "$template"; exit 2; }
[ ! -e "$target" ] || { err "already exists: %s" "$target"; exit 2; }

cp "$template" "$target"
chmod +x "$target" 2>/dev/null || :

# Prepare replacements for template placeholders
set -- "$target" "__CMD_NAME__" "$cmd_name" "__CMD_USAGE_PATH__" "$usage_path"

if [ "$GROUP" -eq 1 ]; then
  child_list=$(find "$target_dir" -mindepth 1 -maxdepth 1 \( -type f -perm -u+x -o -type d \) -printf '%f\n' 2>/dev/null |
    LC_ALL=C sort |
    while IFS= read -r name; do
      case "$name" in
        __main|.*) continue ;;
      esac
      printf '%s\n' "$name"
    done)
  [ -n "$child_list" ] || child_list='<subcommand>'
  first_child=$(printf '%s\n' "$child_list" | head -n 1)
  set -- "$@" "__CMD_SUBCOMMANDS__" "$child_list" "__FIRST_CHILD__" "$first_child"
fi

python3 - "$@" <<'__NEW_REWRITE__'
import pathlib, sys
path = pathlib.Path(sys.argv[1])
content = path.read_text()
args = sys.argv[2:]
for i in range(0, len(args), 2):
    key = args[i]
    value = args[i + 1]
    content = content.replace(key, value)
path.write_text(content)
__NEW_REWRITE__

inf "created %s" "${target#$TOOLS_DIR/}"
